{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Protect Flask routes with AWS Cognito","text":"<p>A Flask extension that supports protecting routes with AWS Cognito following OAuth 2.1 best practices. That means the full authorization code flow, including Proof Key for Code Exchange (RFC 7636) to prevent Cross Site Request Forgery (CSRF), along with secure storage of access tokens in HTTP only cookies (to prevent Cross Site Scripting attacks), and additional <code>nonce</code> validation (if using ID tokens) to prevent replay attacks.</p> <p>Optionally, OAuth refresh flow can be enabled, with the refresh token stored in a HTTP-only cookie with optional Fernet symmetrical encryption using Flask's <code>SECRET_KEY</code> (encryption is enabled by default).</p> <p>Documentation: https://mblackgeo.github.io/flask-cognito-lib</p> <p>Source Code: https://github.com/mblackgeo/flask-cognito-lib</p>"},{"location":"#installation","title":"Installation","text":"<p>Use the package manager pip to install:</p> <pre><code>pip install flask-cognito-lib\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<p>To get started quickly, a complete example Flask application is provided in <code>/example</code> including instructions on setting up a Cognito User Pool. A separate repo holds a complete example app, including AWS CDK (Cloud Development Kit) code to deploy the application to API Gateway and Lambda, along with creation of a Cognito User Pool and Client. However, assuming a Cognito user pool has been setup with an app client (with Client ID and Secret), get started as follows:</p> <pre><code>from flask import Flask, jsonify, redirect, session, url_for\n\nfrom flask_cognito_lib import CognitoAuth\nfrom flask_cognito_lib.decorators import (\n    auth_required,\n    cognito_login,\n    cognito_login_callback,\n    cognito_logout,\n    cognito_refresh_callback,\n)\n\napp = Flask(__name__)\n\n# Configuration required for CognitoAuth\napp.config[\"AWS_REGION\"] = \"eu-west-1\"\napp.config[\"AWS_COGNITO_USER_POOL_ID\"] = \"eu-west-1_qwerty\"\napp.config[\"AWS_COGNITO_DOMAIN\"] = \"https://app.auth.eu-west-1.amazoncognito.com\"\napp.config[\"AWS_COGNITO_USER_POOL_CLIENT_ID\"] = \"asdfghjkl1234asdf\"\napp.config[\"AWS_COGNITO_USER_POOL_CLIENT_SECRET\"] = \"zxcvbnm1234567890\"\napp.config[\"AWS_COGNITO_REDIRECT_URL\"] = \"https://example.com/postlogin\"\napp.config[\"AWS_COGNITO_LOGOUT_URL\"] = \"https://example.com/postlogout\"\napp.config[\"AWS_COGNITO_REFRESH_FLOW_ENABLED\"] = True\napp.config[\"AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED\"] = True\napp.config[\"AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS\"] = 86400\n\n\nauth = CognitoAuth(app)\n\n\n@app.route(\"/login\")\n@cognito_login\ndef login():\n    # A simple route that will redirect to the Cognito Hosted UI.\n    # No logic is required as the decorator handles the redirect to the Cognito\n    # hosted UI for the user to sign in.\n    # An optional \"state\" value can be set in the current session which will\n    # be passed and then used in the postlogin route (after the user has logged\n    # into the Cognito hosted UI); this could be used for dynamic redirects,\n    # for example, set `session['state'] = \"some_custom_value\"` before passing\n    # the user to this route\n    pass\n\n\n@app.route(\"/postlogin\")\n@cognito_login_callback\ndef postlogin():\n    # A route to handle the redirect after a user has logged in with Cognito.\n    # This route must be set as one of the User Pool client's Callback URLs in\n    # the Cognito console and also as the config value AWS_COGNITO_REDIRECT_URL.\n    # The decorator will store the validated access token in a HTTP only cookie\n    # and the user claims and info are stored in the Flask session:\n    # session[\"claims\"] and session[\"user_info\"].\n    # Do anything after the user has logged in here, e.g. a redirect or perform\n    # logic based on a custom `session['state']` value if that was set before\n    # login\n    return redirect(url_for(\"claims\"))\n\n\n@app.route(\"/refresh\", methods=[\"POST\"])\n@cognito_refresh_callback\ndef refresh():\n    # A route to handle the token refresh with Cognito.\n    # The decorator will exchange the refresh token for new access and refresh tokens.\n    # The new validated access token will be stored in an HTTP only secure cookie.\n    # The refresh token will be symmetrically encrypted(by default)\n    # and stored in an HTTP only secure cookie.\n    # The user claims and info are stored in the Flask session:\n    # session[\"claims\"] and session[\"user_info\"].\n    # Do anything after the user has refreshed access token here, e.g. a redirect\n    # or perform logic based on the `session[\"user_info\"]`.\n    pass\n\n\n@app.route(\"/claims\")\n@auth_required()\ndef claims():\n    # This route is protected by the Cognito authorisation. If the user is not\n    # logged in at this point or their token from Cognito is no longer valid\n    # a 401 Authentication Error is thrown, which can be caught by registering\n    # an `@app.error_handler(AuthorisationRequiredError)`.\n    # If their session is valid, the current session will be shown including\n    # their claims and user_info extracted from the Cognito tokens.\n    return jsonify(session)\n\n\n@app.route(\"/admin\")\n@auth_required(groups=[\"admin\"])\ndef admin():\n    # This route will only be accessible to a user who is a member of all of\n    # groups specified in the \"groups\" argument on the auth_required decorator\n    # If they are not, a 401 Authentication Error is thrown, which can be caught\n    # by registering an `@app.error_handler(CognitoGroupRequiredError)`.\n    # If their session is valid, the set of groups the user is a member of will be\n    # shown.\n\n    # Could also use: jsonify(session[\"user_info\"][\"cognito:groups\"])\n    return jsonify(session[\"claims\"][\"cognito:groups\"])\n\n\n@app.route(\"/edit\")\n@auth_required(groups=[\"admin\", \"editor\"], any_group=True)\ndef edit():\n    # This route will only be accessible to a user who is a member of any of\n    # groups specified in the \"groups\" argument on the auth_required decorator\n    # If they are not, a CognitoGroupRequiredError is raised.\n    return jsonify(session[\"claims\"][\"cognito:groups\"])\n\n\n@app.route(\"/logout\")\n@cognito_logout\ndef logout():\n    # Logout of the Cognito User pool and delete the cookies that were set\n    # on login.\n    # Revokes the refresh token to not be used again and removes the cookie.\n    # No logic is required here as it simply redirects to Cognito.\n    pass\n\n\n@app.route(\"/postlogout\")\ndef postlogout():\n    # This is the endpoint Cognito redirects to after a user has logged out,\n    # handle any logic here, like returning to the homepage.\n    # This route must be set as one of the User Pool client's Sign Out URLs.\n    return redirect(url_for(\"home\"))\n\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"#config-class-override","title":"Config class override","text":"<p>There might be some cases where you want to override the default <code>Config</code> class to add custom logic. For example, to generate the <code>redirect_url</code> and <code>logout_redirect</code> dynamically using <code>url_for</code>, you can override the <code>Config</code> class as follows:</p> <pre><code>from flask import url_for\nfrom flask_cognito_lib.config import Config\n\nclass ConfigOverride(Config):\n    \"\"\"\n    ConfigOverride class to generate URLs dynamically using `url_for`\n    \"\"\"\n    @property\n    def redirect_url(self) -&gt; str:\n        \"\"\"Return the Redirect URL (post-login)\"\"\"\n        return url_for(endpoint='auth.cognito', _external=True)\n\n    @property\n    def logout_redirect(self) -&gt; str:\n        \"\"\"Return the Redirect URL (post-logout)\"\"\"\n        return url_for(endpoint='auth.cognito_post_logout', _external=True)\n</code></pre> <p>Then, pass the object of <code>ConfigOverride</code> class when initializing the <code>CognitoAuth</code> plugin as follows:</p> <pre><code>CognitoAuth(app, cfg=ConfigOverride())\n</code></pre> <p>Or if you are using lazy initialization:</p> <pre><code>CognitoAuth().init_app(app, cfg=ConfigOverride())\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>Prerequisites:</p> <ul> <li>uv</li> </ul> <p>The Makefile includes helpful commands setting a development environment, get started by installing the package into a new environment by running <code>make install</code>. Run <code>make help</code> to see additional available commands (e.g. linting, testing and so on).</p> <ul> <li>Pytest is used for testing the application (see <code>/tests</code>).</li> <li>MkDocs is used for generating docs and hosted with GH pages (see <code>/docs</code>).</li> <li>Code is linted and formatted using ruff</li> <li>Type hints are validated using mypy</li> <li>The Github Actions pipeline runs these checks and tests</li> <li>Semantic-release is used with conventional commits for automated releasing to PyPI</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change. Please make sure to update tests as appropriate and ensure at least 95% test coverage across the whole project.</p>"},{"location":"#credits","title":"Credits","text":"<p>This work started as a fork of the unmaintained Flask-AWSCognito extension, revising the implementation following OAuth 2.1 recommendations, with inspiration from flask-cognito-auth. Whilst there are several Cognito extensions available for Flask, none of those implement OAuth 2.1 recommendations, with some plugins not even actively maintained.</p>"},{"location":"cognito/","title":"Setting up a Cognito User Pool and client","text":""},{"location":"cognito/#about-cognito","title":"About Cognito","text":"<p>Cognito is a serverless offering from Amazon Web Services that allows for sign-up/sign-in and user management with OAuth 2.0 and OpenID Connect, as well as federated identities through social identity providers (e.g. Google, Facebook, Amazon) and SAML. It has a generous free tier, with 50,000 monthly active users from the Cognito IdP. To get start protecting routes in your Flask app, first create a new Cognito User Pool and a client for the application:</p>"},{"location":"cognito/#setup-steps","title":"Setup steps","text":"<ul> <li>Visit the AWS Cognito console, click to create a new user pool (\"Add user directories to your app\")</li> <li>Step 1: Ensure the \"Cognito user pool\" provider is checked, choose any additional sign-in options as required</li> <li>Step 2: Configure your security requirements as needed (e.g. Multi-Factor Authentication, password policy)</li> <li>Step 3: Configure your sign-up experience as required, or leave to defaults</li> <li>Step 4: Configure message delivery, for production apps you should use SES, for testing \"Send email with Cognito\" is sufficient</li> <li>Step 5: Integrate your app<ul> <li>Name the user pool</li> <li>Check the box to enable the Hosted UI</li> <li>Setup a domain for the user pool (either a custom domain or the domain prefix)</li> <li>Choose \"Confidential Client\"</li> <li>Set the \"App client name\"</li> <li>Ensure the box is checked to \"Create a client secret\"</li> <li>Under \"Allowed callback URLs\" add the URL of the route that has the <code>@cognito_login_callback</code> - for the example app this should be <code>http://localhost:5000/postlogin</code></li> <li>Expand the \"Advanced app client settings\"<ul> <li>Set the Refresh, Access, and ID Token expiration values to the desired session length for the user (note that refresh tokens are not used)</li> <li>Locate the \"Add Signout URL\" button and add the URL of the route handles logic after logout - for the example app this should be <code>http://localhost:5000/postlogout</code></li> </ul> </li> </ul> </li> <li>Review all settings and hit \"Create\"</li> <li>After creation, add users and groups as required</li> </ul>"},{"location":"config/","title":"Application configuration","text":""},{"location":"config/#cognito-auth-extension-configuration","title":"Cognito Auth extension configuration","text":"<p>The following key/value pairs are used for configurating the extension:</p> Config Name Description <code>AWS_COGNITO_DISABLED</code> Globally disable auth with Cognito (default=False) <code>AWS_REGION</code> Region the user pool was created <code>AWS_COGNITO_DOMAIN</code> The domain name of the user pool <code>AWS_COGNITO_USER_POOL_ID</code> The ID of the user pool <code>AWS_COGNITO_USER_POOL_CLIENT_ID</code> The user pool app client ID (*) <code>AWS_COGNITO_USER_POOL_CLIENT_SECRET</code> The user pool app client secret (*) [Optional for public Cognito clients] <code>AWS_COGNITO_REDIRECT_URL</code> The full URL of the route that handles post-login flow <code>AWS_COGNITO_LOGOUT_URL</code> The full URL of the route that handles post-logout flow <code>AWS_COGNITO_COOKIE_AGE_SECONDS</code> (Optional) How long to store the access token cookie. (default=1800) <code>AWS_COGNITO_EXPIRATION_LEEWAY</code> (Optional) Leeway (in seconds) when checking for token expiry (default=0) <code>AWS_COGNITO_SCOPES</code> (Optional) List of scopes to request from Cognito, if None (default) will get all scopes <code>AWS_COGNITO_COOKIE_DOMAIN</code> (Optional) Domain used for setting a cookie (default=None) <code>AWS_COGNITO_COOKIE_SAMESITE</code> (Optional) Setting for \"samesite\" on the cookie. Choose \"lax\", \"strict\" or None (default) <code>AWS_COGNITO_REFRESH_FLOW_ENABLED</code> (Optional) Enable refresh token flow (default=False) <code>AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED</code> (Optional) Symmetrically encrypt a refresh token cookie using Fernet with the Flask <code>SECRET_KEY</code> (default=True) <code>AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS</code> (Optional) How long to store the refresh token cookie. (default=86400) <p>(*) To obtain these values, navigate to the user pool in the AWS Cognito console, then head to the \"App Integration\" tab. Under the app client list, select the app client and you should be able to view the Client ID and Client Secret</p>"},{"location":"config/#example-usage","title":"Example usage","text":"<p>These configuration should be setup and passed to the Flask app object, for example, if they are set in environment variables this could be achieved as follows:</p> <pre><code>from os import environ\nfrom flask import Flask\n\nclass Config:\n    \"\"\"Set Flask configuration vars from .env file.\"\"\"\n\n    # General Config\n    SECRET_KEY = environ.get(\"SECRET_KEY\", urandom(32))\n    FLASK_APP = \"TEST_APP\"\n    FLASK_ENV = \"TESTING\"\n\n    # Cognito config\n    AWS_REGION = environ[\"AWS_REGION\"]\n    AWS_COGNITO_USER_POOL_ID = environ[\"AWS_COGNITO_USER_POOL_ID\"]\n    AWS_COGNITO_DOMAIN = environ[\"AWS_COGNITO_DOMAIN\"]\n    AWS_COGNITO_USER_POOL_CLIENT_ID = environ[\"AWS_COGNITO_USER_POOL_CLIENT_ID\"]\n    AWS_COGNITO_USER_POOL_CLIENT_SECRET = environ[\"AWS_COGNITO_USER_POOL_CLIENT_SECRET\"]\n    AWS_COGNITO_REDIRECT_URL = environ[\"AWS_COGNITO_REDIRECT_URL\"]\n    AWS_COGNITO_LOGOUT_URL = environ[\"AWS_COGNITO_LOGOUT_URL\"]\n\n    # Optional\n    # AWS_COGNITO_COOKIE_AGE_SECONDS = environ[\"AWS_COGNITO_COOKIE_AGE_SECONDS\"]\n    # AWS_COGNITO_EXPIRATION_LEEWAY = environ[\"AWS_COGNITO_EXPIRATION_LEEWAY]\n    # AWS_COGNITO_SCOPES = [\"openid\", \"phone\", \"email\"]\n    # AWS_COGNITO_REFRESH_FLOW_ENABLED = environ[\"AWS_COGNITO_REFRESH_FLOW_ENABLED\"]\n    # AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED = environ[\"AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED\"]\n    # AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS = environ[\"AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS\"]\n\n\napp = Flask(__name__)\napp.config.from_object(Config)\n</code></pre>"},{"location":"example/","title":"Example Flask application","text":"<p>A separate repo holds a complete example app, including AWS CDK (Cloud Development Kit) code to deploy the application to API Gateway and Lambda, along with creation of a Cognito User Pool and Client.</p> <p>However, a mimimal example application is shown below that demonstrates the features:</p> app.py<pre><code>from os import environ, path, urandom\n\nfrom dotenv import load_dotenv\nfrom flask import Flask, jsonify, redirect, session, url_for\n\nfrom flask_cognito_lib import CognitoAuth\nfrom flask_cognito_lib.decorators import (\n    auth_required,\n    cognito_login,\n    cognito_login_callback,\n    cognito_logout,\n    cognito_refresh_callback,\n)\nfrom flask_cognito_lib.exceptions import (\n    AuthorisationRequiredError,\n    CognitoGroupRequiredError,\n)\n\n# Load variables from .env\nbasedir = path.abspath(path.dirname(__file__))\nload_dotenv(path.join(basedir, \".env\"))\n\n\nclass Config:\n    \"\"\"Set Flask configuration vars from .env file.\"\"\"\n\n    # General Config\n    SECRET_KEY = environ.get(\"SECRET_KEY\", urandom(32))\n    FLASK_APP = \"TEST_APP\"\n    FLASK_ENV = \"TESTING\"\n\n    # Cognito config\n    # AWS_COGNITO_DISABLED = True  # Can set to turn off auth (e.g. for local testing)\n    AWS_REGION = environ[\"AWS_REGION\"]\n    AWS_COGNITO_USER_POOL_ID = environ[\"AWS_COGNITO_USER_POOL_ID\"]\n    AWS_COGNITO_DOMAIN = environ[\"AWS_COGNITO_DOMAIN\"]\n    AWS_COGNITO_USER_POOL_CLIENT_ID = environ[\"AWS_COGNITO_USER_POOL_CLIENT_ID\"]\n    AWS_COGNITO_USER_POOL_CLIENT_SECRET = environ[\"AWS_COGNITO_USER_POOL_CLIENT_SECRET\"]\n    AWS_COGNITO_REDIRECT_URL = environ[\"AWS_COGNITO_REDIRECT_URL\"]\n    AWS_COGNITO_LOGOUT_URL = environ[\"AWS_COGNITO_LOGOUT_URL\"]\n    AWS_COGNITO_COOKIE_AGE_SECONDS = environ[\"AWS_COGNITO_COOKIE_AGE_SECONDS\"]\n    AWS_COGNITO_REFRESH_FLOW_ENABLED = environ[\"AWS_COGNITO_REFRESH_FLOW_ENABLED\"]\n    AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED = environ[\n        \"AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED\"\n    ]\n    AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS = environ[\n        \"AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS\"\n    ]\n\n\napp = Flask(__name__)\napp.config.from_object(Config)\nauth = CognitoAuth(app)\n\n\n@app.route(\"/\")\ndef home():\n    return \"Hello world!\"\n\n\n@app.route(\"/login\")\n@cognito_login\ndef login():\n    # A simple route that will redirect to the Cognito Hosted UI.\n    # No logic is required as the decorator handles the redirect to the Cognito\n    # hosted UI for the user to sign in.\n    # An optional \"state\" value can be set in the current session which will\n    # be passed and then used in the postlogin route (after the user has logged\n    # into the Cognito hosted UI); this could be used for dynamic redirects,\n    # for example, set `session['state'] = \"some_custom_value\"` before passing\n    # the user to this route\n    pass\n\n\n@app.route(\"/postlogin\")\n@cognito_login_callback\ndef postlogin():\n    # A route to handle the redirect after a user has logged in with Cognito.\n    # This route must be set as one of the User Pool client's Callback URLs in\n    # the Cognito console and also as the config value AWS_COGNITO_REDIRECT_URL.\n    # The decorator will store the validated access token in a HTTP only cookie\n    # and the user claims and info are stored in the Flask session:\n    # session[\"claims\"] and session[\"user_info\"].\n    # Do anything after the user has logged in here, e.g. a redirect or perform\n    # logic based on a custom `session['state']` value if that was set before\n    # login\n    return redirect(url_for(\"claims\"))\n\n\n@app.route(\"/refresh\", methods=[\"POST\"])\n@cognito_refresh_callback\ndef refresh():\n    # A route to handle the token refresh with Cognito.\n    # The decorator will exchange the refresh token for new access and refresh tokens.\n    # The new validated access token will be stored in an HTTP only secure cookie.\n    # The refresh token will be symmetrically encrypted(by default)\n    # and stored in an HTTP only secure cookie.\n    # The user claims and info are stored in the Flask session:\n    # session[\"claims\"] and session[\"user_info\"].\n    # Do anything after the user has refreshed access token here, e.g. a redirect\n    # or perform logic based on the `session[\"user_info\"]`.\n    pass\n\n\n@app.route(\"/claims\")\n@auth_required()\ndef claims():\n    # This route is protected by the Cognito authorisation. If the user is not\n    # logged in at this point or their token from Cognito is no longer valid\n    # a 401 Authentication Error is thrown, which is caught by the\n    # `auth_error_handler` a redirected to the Hosted UI to login.\n    # If their auth is valid, the current session will be shown including\n    # their claims and user_info extracted from the Cognito tokens.\n    return jsonify(session)\n\n\n@app.errorhandler(AuthorisationRequiredError)\ndef auth_error_handler(err):\n    # Register an error handler if the user hits an \"@auth_required\" route\n    # but is not logged in to redirect them to the Cognito UI\n    return redirect(url_for(\"login\"))\n\n\n@app.route(\"/admin\")\n@auth_required(groups=[\"admin\"])\ndef admin():\n    # This route will only be accessible to a user who is a member of all of\n    # groups specified in the \"groups\" argument on the auth_required decorator\n    # If they are not, a CognitoGroupRequiredError is raised which is handled\n    # by the `missing_group_error_handler` below.\n    # If their auth is valid, the set of groups the user is a member of will be\n    # shown.\n\n    # Could also use: jsonify(session[\"user_info\"][\"cognito:groups\"])\n    return jsonify(session[\"claims\"][\"cognito:groups\"])\n\n\n@app.route(\"/edit\")\n@auth_required(groups=[\"admin\", \"editor\"], any_group=True)\ndef edit():\n    # This route will only be accessible to a user who is a member of any of\n    # groups specified in the \"groups\" argument on the auth_required decorator\n    # If they are not, a CognitoGroupRequiredError is raised which is handled\n    # below.\n    return jsonify(session[\"claims\"][\"cognito:groups\"])\n\n\n@app.errorhandler(CognitoGroupRequiredError)\ndef missing_group_error_handler(err):\n    # Register an error handler if the user hits an \"@auth_required\" route\n    # but is not in all of groups specified\n    return jsonify(\"Group membership does not allow access to this resource\"), 403\n\n\n@app.route(\"/logout\")\n@cognito_logout\ndef logout():\n    # Logout of the Cognito User pool and delete the cookies that were set\n    # on login.\n    # Revokes the refresh token to not be used again and removes the cookie.\n    # No logic is required here as it simply redirects to Cognito.\n    pass\n\n\n@app.route(\"/postlogout\")\ndef postlogout():\n    # This is the endpoint Cognito redirects to after a user has logged out,\n    # handle any logic here, like returning to the homepage.\n    # This route must be set as one of the User Pool client's Sign Out URLs.\n    return redirect(url_for(\"home\"))\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=5000)\n</code></pre> <p>Requirements file:</p> requirements.txt<pre><code>python-dotenv==1.2.1\nflask-cognito-lib~=1.9\n</code></pre>"}]}